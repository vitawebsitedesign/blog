---
layout: default
---
<h1>How Task.WhenAll() improves performance</h1>

<p>
  Task.WhenAll() runs asynchronous tasks in parallel.
  <br>
  Which code sample below is faster?
</p>

<pre>
private static async Task TestAsyncSequential()
{
    await EmptyTask();
    await EmptyTask();
    await EmptyTask();
}
</pre>

<pre>
private static async Task TestAsyncParallel()
{
    await Task.WhenAll(EmptyTask(), EmptyTask(), EmptyTask());
}
</pre>

<a href="https://github.com/vitawebsitedesign/async-parallel-benchmark">https://github.com/vitawebsitedesign/async-parallel-benchmark</a>

<h2>Results</h2>
<h3>Non-parallel awaits</h3>
<img src="https://imgur.com/JIiFtcN" alt="Benchmark for Non-parallel awaits" />
<h3>Parallel awaits via Task.WhenAll()</h3>
<img src="https://imgur.com/TWpHMmI" alt="Benchmark for Parallel awaits via Task.WhenAll()" />

<p>
  Some articles claim that code sample #1 is not faster, since returned Task are hot (i.e.: Task-based Async Pattern).
  <br>
  <br>
  However this is incorrect, because the 2nd task isn't "returned" until the 1st await finishes.
  <br>
  <br>
  If you're using the Task.WhenAll(IEnumerable<Task<TResult>>) overload, just ensure you dont blow up your computer & that the code remains scalable (e.g.: if number of tasks in list grows, or if task is updated in future to do more IO/CPU)
</p>
