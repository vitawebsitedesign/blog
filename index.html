---
layout: default
---
<h1>How Task.WhenAll() improves performance</h1>

Task.WhenAll() runs asynchronous tasks in parallel.

Which code sample below is faster?

https://github.com/vitawebsitedesign/async-parallel-benchmark

Results:

<blockquote class="imgur-embed-pub" lang="en" data-id="a/DkNrZZ3" data-context="false" ><a href="//imgur.com/a/DkNrZZ3"></a></blockquote><script async src="//s.imgur.com/min/embed.js" charset="utf-8"></script>

<blockquote class="imgur-embed-pub" lang="en" data-id="a/IvsrYQD" data-context="false" ><a href="//imgur.com/a/IvsrYQD"></a></blockquote><script async src="//s.imgur.com/min/embed.js" charset="utf-8"></script>

Some articles claim that code sample #1 is not faster, since returned Task are hot (i.e.: Task-based Async Pattern).

However this is incorrect, because the 2nd task isn't "returned" until the 1st await finishes.

If you're using the Task.WhenAll(IEnumerable<Task<TResult>>) overload, just ensure you dont blow up your computer & that the code remains scalable (e.g.: if number of tasks in list grows, or if task is updated in future to do more IO/CPU)
